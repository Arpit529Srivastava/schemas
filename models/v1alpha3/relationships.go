// Package v1alpha3 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package v1alpha3

import (
	"encoding/json"
	"fmt"

	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for RelationshipKind.
const (
	Edge         RelationshipKind = "Edge"
	Hierarchical RelationshipKind = "Hierarchical"
	Sibling      RelationshipKind = "Sibling"
)

// Defines values for RelationshipModelStatus.
const (
	RelationshipModelStatusDuplicate RelationshipModelStatus = "duplicate"
	RelationshipModelStatusEnabled   RelationshipModelStatus = "enabled"
	RelationshipModelStatusIgnored   RelationshipModelStatus = "ignored"
)

// Defines values for RelationshipSelectorsAllowFromModelStatus.
const (
	RelationshipSelectorsAllowFromModelStatusDuplicate RelationshipSelectorsAllowFromModelStatus = "duplicate"
	RelationshipSelectorsAllowFromModelStatusEnabled   RelationshipSelectorsAllowFromModelStatus = "enabled"
	RelationshipSelectorsAllowFromModelStatusIgnored   RelationshipSelectorsAllowFromModelStatus = "ignored"
)

// Defines values for RelationshipSelectorsAllowFromPatchPatchStrategy.
const (
	RelationshipSelectorsAllowFromPatchPatchStrategyReplace RelationshipSelectorsAllowFromPatchPatchStrategy = "replace"
)

// Defines values for RelationshipSelectorsAllowToModelStatus.
const (
	RelationshipSelectorsAllowToModelStatusDuplicate RelationshipSelectorsAllowToModelStatus = "duplicate"
	RelationshipSelectorsAllowToModelStatusEnabled   RelationshipSelectorsAllowToModelStatus = "enabled"
	RelationshipSelectorsAllowToModelStatusIgnored   RelationshipSelectorsAllowToModelStatus = "ignored"
)

// Defines values for RelationshipSelectorsAllowToPatchPatchStrategy.
const (
	RelationshipSelectorsAllowToPatchPatchStrategyReplace RelationshipSelectorsAllowToPatchPatchStrategy = "replace"
)

// Defines values for RelationshipSelectorsDenyFromModelStatus.
const (
	RelationshipSelectorsDenyFromModelStatusDuplicate RelationshipSelectorsDenyFromModelStatus = "duplicate"
	RelationshipSelectorsDenyFromModelStatusEnabled   RelationshipSelectorsDenyFromModelStatus = "enabled"
	RelationshipSelectorsDenyFromModelStatusIgnored   RelationshipSelectorsDenyFromModelStatus = "ignored"
)

// Defines values for RelationshipSelectorsDenyFromPatchPatchStrategy.
const (
	RelationshipSelectorsDenyFromPatchPatchStrategyReplace RelationshipSelectorsDenyFromPatchPatchStrategy = "replace"
)

// Defines values for RelationshipSelectorsDenyToModelStatus.
const (
	Duplicate RelationshipSelectorsDenyToModelStatus = "duplicate"
	Enabled   RelationshipSelectorsDenyToModelStatus = "enabled"
	Ignored   RelationshipSelectorsDenyToModelStatus = "ignored"
)

// Defines values for RelationshipSelectorsDenyToPatchPatchStrategy.
const (
	RelationshipSelectorsDenyToPatchPatchStrategyReplace RelationshipSelectorsDenyToPatchPatchStrategy = "replace"
)

type Model struct {
	// Category Category of the model.
	Category string `json:"category" yaml:"category"`

	// Description Description of the model.
	Description *string `json:"description" yaml:"description"`

	// DisplayName Human-readable name for the model.
	DisplayName *string `json:"displayName" yaml:"displayName"`

	// Metadata Metadata containing additional information associated with the model.
	Metadata *Model_Metadata `json:"metadata,omitempty"`

	// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31)
	Model *struct {
		// Version Version of the model as defined by the registrant.
		Version string `json:"version" yaml:"version"`
	} `json:"model,omitempty"`

	// Name The unique name for the model within the scope of a registrant.
	Name       string                 `json:"name" yaml:"name"`
	Registrant map[string]interface{} `json:"registrant" yaml:"registrant"`

	// SchemaVersion Specifies the version of the schema used for the definition.
	SchemaVersion *string `json:"schemaVersion" yaml:"schemaVersion"`

	// Status Status of model, including:
	// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
	// - maintenance: model is unavailable for a period of time.
	// - enabled: model is available for use for all users of this Meshery Server.
	// - ignored: model is unavailable for use for all users of this Meshery Server.
	Status *ModelStatus `json:"status" yaml:"status"`

	// SubCategory Sub-category of the model.
	SubCategory *string `json:"subCategory" yaml:"subCategory"`

	// Version Version of the model definition.
	Version string `json:"version" yaml:"version"`
}

// ModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type ModelStatus string

// Model_Metadata Metadata containing additional information associated with the model.
type Model_Metadata struct {
	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor *string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite             *string                `json:"svgWhite" yaml:"svgWhite"`
	AdditionalProperties map[string]interface{} `json:"-"`
}


// Relationship Relationships define the nature of interaction between interconnected components in Meshery. The combination of relationship properties kind, type, and subtype characterize various genealogical relations among and between components. Relationships have selectors, selector sets, metadata, and optional parameters. Learn more at https://docs.meshery.io/concepts/logical/relationships.
type Relationship struct {
	// EvaluationQuery Optional. Assigns the policy to be used for the evaluation of the relationship. Deprecation Notice: In the future, this property is either to be removed or to it is to be an array of optional policy $refs.
	EvaluationQuery *string `json:"evaluationQuery" yaml:"evaluationQuery"`

	// Kind Kind of the Relationship. Learn more about relationships - https://docs.meshery.io/concepts/logical/relationships.
	Kind RelationshipKind `json:"kind" yaml:"kind"`

	// Metadata Metadata contains additional information associated with the Relationship.
	Metadata *struct {
		// Description Characteristization of the meaning of the relationship and its relevance to both Meshery and entities under management.
		Description *string `json:"description" yaml:"description"`
	} `json:"metadata,omitempty"`

	// Model Name of the model in which this relationship is packaged.
	Model Model `json:"model,omitempty" yaml:"model"`

	// SchemaVersion Specifies the version of the schema used for the relationship definition.
	SchemaVersion string `json:"schemaVersion" yaml:"schemaVersion"`

	// Selectors Selectors are organized as an array, with each item containing a distinct set of selectors that share a common functionality. This structure allows for flexibility in defining relationships, even when different components are involved.
	Selectors *[]struct {
		// Allow Selectors used to define relationships which are allowed.
		Allow struct {
			From []struct {
				// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
				Id    *openapi_types.UUID `json:"id" yaml:"id"`
				Kind  *string             `json:"kind" yaml:"kind"`
				Match *struct {
					// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
					Id *openapi_types.UUID `json:"id" yaml:"id"`

					// Kind Optional property which defines paths which should be matched with 'self'. Here 'kind' is valid Component 'kind' belonging to the above specifed model. eg: If model is Kubernetes, valid 'kind' are 'Pod', 'Secret'. If the value for all paths of 'self' & 'kind' along with the value of all paths inside 'to.match.self' & 'to.match.kind are equal then the component with 'kind' act as an binded component. eg: ClusterRole, ClusterRoleBinding and ServiceAccount. If the paths for ClusterRole & ClusterRoleBinding and ServiceAccount & ClusterRoleBinding are equal then ClusterRoleBinding acts as an binding. Make sure the 'kind' value in 'from' and 'to' should be equal.
					Kind *[]string `json:"kind,omitempty"`

					// Self Defines paths which should be matched with the 'kind' property.
					Self *[]string `json:"self,omitempty"`
				} `json:"match,omitempty"`

				// Model Name of the model implicated by this selector. Learn more at https://docs.meshery.io/concepts/models
				Model *Model `json:"model,omitempty" yaml:"model"`
				Patch *struct {
					// MutatorRef JSON ref to value from where patch should be applied.
					MutatorRef    *[][]string                                       `json:"mutatorRef,omitempty"`
					PatchStrategy *RelationshipSelectorsAllowFromPatchPatchStrategy `json:"patchStrategy" yaml:"patchStrategy"`
				} `json:"patch,omitempty"`
			} `json:"from"`
			To []struct {
				// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
				Id    *openapi_types.UUID `json:"id" yaml:"id"`
				Kind  *string             `json:"kind" yaml:"kind"`
				Match *struct {
					// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
					Id *openapi_types.UUID `json:"id" yaml:"id"`

					// Kind Optional property which defines paths which should be matched with 'self'. Here 'kind' is valid Component 'kind' belonging to the above specifed model. eg: If model is Kubernetes, valid 'kind' are 'Pod', 'Secret'. If the value for all paths of 'self' & 'kind' along with the value of all paths inside 'to.match.self' & 'to.match.kind are equal then the component with 'kind' act as an binded component. eg: ClusterRole, ClusterRoleBinding and ServiceAccount. If the paths for ClusterRole & ClusterRoleBinding and ServiceAccount & ClusterRoleBinding are equal then ClusterRoleBinding acts as an binding. Make sure the 'kind' value in 'from' and 'to' should be equal.
					Kind *[]string `json:"kind,omitempty"`

					// Self Defines paths which should be matched with 'kind'.
					Self *[]string `json:"self,omitempty"`
				} `json:"match,omitempty"`

				// Model Model of the implicated component. Learn more at https://docs.meshery.io/concepts/models
				Model *Model `json:"model,omitempty" yaml:"model"`
				Patch *struct {
					// MutatedRef JSONPath (https://en.wikipedia.org/wiki/JSONPath) to property to be patched.
					MutatedRef    *string                                         `json:"mutatedRef" yaml:"mutatedRef"`
					PatchStrategy *RelationshipSelectorsAllowToPatchPatchStrategy `json:"patchStrategy" yaml:"patchStrategy"`
				} `json:"patch,omitempty"`
			} `json:"to"`
		} `json:"allow"`

		// Deny Optional selectors used to define relationships which should not be created / is restricted.
		Deny *struct {
			From []struct {
				// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
				Id    *openapi_types.UUID `json:"id" yaml:"id"`
				Kind  *string             `json:"kind" yaml:"kind"`
				Match *struct {
					// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
					Id *openapi_types.UUID `json:"id" yaml:"id"`

					// Kind Optional property which defines paths which should be matched with 'self'. Here 'kind' is valid Component 'kind' belonging to the above specifed model. eg: If model is Kubernetes, valid 'kind' are 'Pod', 'Secret'. If the value for all paths of 'self' & 'kind' along with the value of all paths inside 'to.match.self' & 'to.match.kind are equal then the component with 'kind' act as an binded component. eg: ClusterRole, ClusterRoleBinding and ServiceAccount. If the paths for ClusterRole & ClusterRoleBinding and ServiceAccount & ClusterRoleBinding are equal then ClusterRoleBinding acts as an binding. Make sure the 'kind' value in 'from' and 'to' should be equal.
					Kind *[]string `json:"kind,omitempty"`

					// Self Defines paths which should be matched with the 'kind' property.
					Self *[]string `json:"self,omitempty"`
				} `json:"match,omitempty"`

				// Model Name of the model implicated by this selector. Learn more at https://docs.meshery.io/concepts/models
				Model *Model `json:"model,omitempty" yaml:"model"`
				Patch *struct {
					// MutatorRef JSON ref to value from where patch should be applied.
					MutatorRef    *[][]string                                      `json:"mutatorRef,omitempty"`
					PatchStrategy *RelationshipSelectorsDenyFromPatchPatchStrategy `json:"patchStrategy" yaml:"patchStrategy"`
				} `json:"patch,omitempty"`
			} `json:"from"`
			To []struct {
				// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
				Id    *openapi_types.UUID `json:"id" yaml:"id"`
				Kind  *string             `json:"kind" yaml:"kind"`
				Match *struct {
					// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
					Id *openapi_types.UUID `json:"id" yaml:"id"`

					// Kind Optional property which defines paths which should be matched with 'self'. Here 'kind' is valid Component 'kind' belonging to the above specifed model. eg: If model is Kubernetes, valid 'kind' are 'Pod', 'Secret'. If the value for all paths of 'self' & 'kind' along with the value of all paths inside 'to.match.self' & 'to.match.kind are equal then the component with 'kind' act as an binded component. eg: ClusterRole, ClusterRoleBinding and ServiceAccount. If the paths for ClusterRole & ClusterRoleBinding and ServiceAccount & ClusterRoleBinding are equal then ClusterRoleBinding acts as an binding. Make sure the 'kind' value in 'from' and 'to' should be equal.
					Kind *[]string `json:"kind,omitempty"`

					// Self Defines paths which should be matched with 'kind'.
					Self *[]string `json:"self,omitempty"`
				} `json:"match,omitempty"`

				// Model Model of the implicated component. Learn more at https://docs.meshery.io/concepts/models
				Model *Model `json:"model,omitempty" yaml:"model"`
				Patch *struct {
					// MutatedRef JSONPath (https://en.wikipedia.org/wiki/JSONPath) to property to be patched.
					MutatedRef    *string                                        `json:"mutatedRef" yaml:"mutatedRef"`
					PatchStrategy *RelationshipSelectorsDenyToPatchPatchStrategy `json:"patchStrategy" yaml:"patchStrategy"`
				} `json:"patch,omitempty"`
			} `json:"to"`
		} `json:"deny,omitempty"`
	} `json:"selectors,omitempty"`

	// SubType Most granular unit of relationship classification. The combination of Kind, Type and SubType together uniquely identify a Relationship.
	SubType string `json:"subType" yaml:"subType"`

	// Type Classification of relationships. Used to group relationships similar in nature.
	Type string `json:"type" yaml:"type"`

	// Version Specifies the version of the relationship definition.
	Version string `json:"version" yaml:"version"`
}

// RelationshipKind Kind of the Relationship. Learn more about relationships - https://docs.meshery.io/concepts/logical/relationships.
type RelationshipKind string

// Relationship_Model_Metadata Metadata containing additional information associated with the model.
type Relationship_Model_Metadata struct {
	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor *string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite             *string                `json:"svgWhite" yaml:"svgWhite"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RelationshipModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipModelStatus string

// RelationshipSelectorsAllowFromModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipSelectorsAllowFromModelStatus string

// RelationshipSelectorsAllowFromPatchPatchStrategy defines model for Relationship.Selectors.Allow.From.Patch.PatchStrategy.
type RelationshipSelectorsAllowFromPatchPatchStrategy string

// RelationshipSelectorsAllowToModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipSelectorsAllowToModelStatus string

// RelationshipSelectorsAllowToPatchPatchStrategy defines model for Relationship.Selectors.Allow.To.Patch.PatchStrategy.
type RelationshipSelectorsAllowToPatchPatchStrategy string

// Relationship_Selectors_Deny_From_Model_Metadata Metadata containing additional information associated with the model.

// RelationshipSelectorsDenyFromModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipSelectorsDenyFromModelStatus string

// RelationshipSelectorsDenyFromPatchPatchStrategy defines model for Relationship.Selectors.Deny.From.Patch.PatchStrategy.
type RelationshipSelectorsDenyFromPatchPatchStrategy string

// RelationshipSelectorsDenyToModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipSelectorsDenyToModelStatus string

// RelationshipSelectorsDenyToPatchPatchStrategy defines model for Relationship.Selectors.Deny.To.Patch.PatchStrategy.
type RelationshipSelectorsDenyToPatchPatchStrategy string

// Getter for additional properties for Relationship_Model_Metadata. Returns the specified
// element and whether it was found
func (a Relationship_Model_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Relationship_Model_Metadata
func (a *Relationship_Model_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Relationship_Model_Metadata to handle AdditionalProperties
func (a *Relationship_Model_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Relationship_Model_Metadata to handle AdditionalProperties
func (a Relationship_Model_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SvgColor != nil {
		object["svgColor"], err = json.Marshal(a.SvgColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
		}
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.SvgWhite != nil {
		object["svgWhite"], err = json.Marshal(a.SvgWhite)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Model_Metadata. Returns the specified
// element and whether it was found
func (a Model_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Model_Metadata
func (a *Model_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Model_Metadata to handle AdditionalProperties
func (a *Model_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Model_Metadata to handle AdditionalProperties
func (a Model_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SvgColor != nil {
		object["svgColor"], err = json.Marshal(a.SvgColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
		}
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.SvgWhite != nil {
		object["svgWhite"], err = json.Marshal(a.SvgWhite)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
