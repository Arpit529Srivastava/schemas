// Package v1alpha3 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package v1alpha3

import (
	"encoding/json"
	"fmt"

	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for RelationshipDefinitionKind.
const (
	Edge         RelationshipDefinitionKind = "Edge"
	Hierarchical RelationshipDefinitionKind = "Hierarchical"
	Sibling      RelationshipDefinitionKind = "Sibling"
)

// Defines values for RelationshipDefinitionModelStatus.
const (
	RelationshipDefinitionModelStatusDuplicate RelationshipDefinitionModelStatus = "duplicate"
	RelationshipDefinitionModelStatusEnabled   RelationshipDefinitionModelStatus = "enabled"
	RelationshipDefinitionModelStatusIgnored   RelationshipDefinitionModelStatus = "ignored"
)

// Defines values for RelationshipDefinitionSelectorsAllowFromModelStatus.
const (
	RelationshipDefinitionSelectorsAllowFromModelStatusDuplicate RelationshipDefinitionSelectorsAllowFromModelStatus = "duplicate"
	RelationshipDefinitionSelectorsAllowFromModelStatusEnabled   RelationshipDefinitionSelectorsAllowFromModelStatus = "enabled"
	RelationshipDefinitionSelectorsAllowFromModelStatusIgnored   RelationshipDefinitionSelectorsAllowFromModelStatus = "ignored"
)

// Defines values for RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy.
const (
	RelationshipDefinitionSelectorsAllowFromPatchPatchStrategyReplace RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy = "replace"
)

// Defines values for RelationshipDefinitionSelectorsAllowToModelStatus.
const (
	RelationshipDefinitionSelectorsAllowToModelStatusDuplicate RelationshipDefinitionSelectorsAllowToModelStatus = "duplicate"
	RelationshipDefinitionSelectorsAllowToModelStatusEnabled   RelationshipDefinitionSelectorsAllowToModelStatus = "enabled"
	RelationshipDefinitionSelectorsAllowToModelStatusIgnored   RelationshipDefinitionSelectorsAllowToModelStatus = "ignored"
)

// Defines values for RelationshipDefinitionSelectorsAllowToPatchPatchStrategy.
const (
	RelationshipDefinitionSelectorsAllowToPatchPatchStrategyReplace RelationshipDefinitionSelectorsAllowToPatchPatchStrategy = "replace"
)

// Defines values for RelationshipDefinitionSelectorsDenyFromModelStatus.
const (
	RelationshipDefinitionSelectorsDenyFromModelStatusDuplicate RelationshipDefinitionSelectorsDenyFromModelStatus = "duplicate"
	RelationshipDefinitionSelectorsDenyFromModelStatusEnabled   RelationshipDefinitionSelectorsDenyFromModelStatus = "enabled"
	RelationshipDefinitionSelectorsDenyFromModelStatusIgnored   RelationshipDefinitionSelectorsDenyFromModelStatus = "ignored"
)

// Defines values for RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy.
const (
	RelationshipDefinitionSelectorsDenyFromPatchPatchStrategyReplace RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy = "replace"
)

// Defines values for RelationshipDefinitionSelectorsDenyToModelStatus.
const (
	Duplicate RelationshipDefinitionSelectorsDenyToModelStatus = "duplicate"
	Enabled   RelationshipDefinitionSelectorsDenyToModelStatus = "enabled"
	Ignored   RelationshipDefinitionSelectorsDenyToModelStatus = "ignored"
)

// Defines values for RelationshipDefinitionSelectorsDenyToPatchPatchStrategy.
const (
	RelationshipDefinitionSelectorsDenyToPatchPatchStrategyReplace RelationshipDefinitionSelectorsDenyToPatchPatchStrategy = "replace"
)

type ModelDefinition struct {
	// Category Category of the model.
	Category string `json:"category" yaml:"category"`

	// Description Description of the model.
	Description *string `json:"description" yaml:"description"`

	// DisplayName Human-readable name for the model.
	DisplayName *string `json:"displayName" yaml:"displayName"`

	// Metadata Metadata containing additional information associated with the model.
	Metadata *RelationshipDefinition_Model_Metadata `json:"metadata,omitempty"`

	// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31)
	Model *struct {
		// Version Version of the model as defined by the registrant.
		Version string `json:"version" yaml:"version"`
	} `json:"model,omitempty"`

	// Name The unique name for the model within the scope of a registrant.
	Name       string                 `json:"name" yaml:"name"`
	Registrant map[string]interface{} `json:"registrant" yaml:"registrant"`

	// SchemaVersion Specifies the version of the schema used for the definition.
	SchemaVersion *string `json:"schemaVersion" yaml:"schemaVersion"`

	// Status Status of model, including:
	// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
	// - maintenance: model is unavailable for a period of time.
	// - enabled: model is available for use for all users of this Meshery Server.
	// - ignored: model is unavailable for use for all users of this Meshery Server.
	Status *RelationshipDefinitionModelStatus `json:"status" yaml:"status"`

	// SubCategory Sub-category of the model.
	SubCategory *string `json:"subCategory" yaml:"subCategory"`

	// Version Version of the model definition.
	Version string `json:"version" yaml:"version"`
}

// RelationshipDefinition Relationships define the nature of interaction between interconnected components in Meshery. The combination of relationship properties kind, type, and subtype characterize various genealogical relations among and between components. Relationships have selectors, selector sets, metadata, and optional parameters. Learn more at https://docs.meshery.io/concepts/logical/relationships.
type RelationshipDefinition struct {
	// EvaluationQuery Optional. Assigns the policy to be used for the evaluation of the relationship. Deprecation Notice: In the future, this property is either to be removed or to it is to be an array of optional policy $refs.
	EvaluationQuery *string `json:"evaluationQuery" yaml:"evaluationQuery"`

	// Kind Kind of the Relationship. Learn more about relationships - https://docs.meshery.io/concepts/logical/relationships.
	Kind RelationshipDefinitionKind `json:"kind" yaml:"kind"`

	// Metadata Metadata contains additional information associated with the Relationship.
	Metadata *struct {
		// Description Characteristization of the meaning of the relationship and its relevance to both Meshery and entities under management.
		Description *string `json:"description" yaml:"description"`
	} `json:"metadata,omitempty"`

	// Model Name of the model in which this relationship is packaged.
	Model ModelDefinition `json:"model"`

	// SchemaVersion Specifies the version of the schema used for the relationship definition.
	SchemaVersion string `json:"schemaVersion" yaml:"schemaVersion"`

	// Selectors Selectors are organized as an array, with each item containing a distinct set of selectors that share a common functionality. This structure allows for flexibility in defining relationships, even when different components are involved.
	Selectors *[]struct {
		// Allow Selectors used to define relationships which are allowed.
		Allow struct {
			From []struct {
				// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
				Id    *openapi_types.UUID `json:"id" yaml:"id"`
				Kind  *string             `json:"kind" yaml:"kind"`
				Match *struct {
					// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
					Id *openapi_types.UUID `json:"id" yaml:"id"`

					// Kind Optional property which defines paths which should be matched with 'self'. Here 'kind' is valid Component 'kind' belonging to the above specifed model. eg: If model is Kubernetes, valid 'kind' are 'Pod', 'Secret'. If the value for all paths of 'self' & 'kind' along with the value of all paths inside 'to.match.self' & 'to.match.kind are equal then the component with 'kind' act as an binded component. eg: ClusterRole, ClusterRoleBinding and ServiceAccount. If the paths for ClusterRole & ClusterRoleBinding and ServiceAccount & ClusterRoleBinding are equal then ClusterRoleBinding acts as an binding. Make sure the 'kind' value in 'from' and 'to' should be equal.
					Kind *[]string `json:"kind,omitempty"`

					// Self Defines paths which should be matched with the 'kind' property.
					Self *[]string `json:"self,omitempty"`
				} `json:"match,omitempty"`

				// Model Name of the model implicated by this selector. Learn more at https://docs.meshery.io/concepts/models
				Model *ModelDefinition `json:"model,omitempty"`
				Patch *struct {
					// MutatorRef JSON ref to value from where patch should be applied.
					MutatorRef    *[][]string                                                 `json:"mutatorRef,omitempty"`
					PatchStrategy *RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy `json:"patchStrategy" yaml:"patchStrategy"`
				} `json:"patch,omitempty"`
			} `json:"from"`
			To []struct {
				// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
				Id    *openapi_types.UUID `json:"id" yaml:"id"`
				Kind  *string             `json:"kind" yaml:"kind"`
				Match *struct {
					// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
					Id *openapi_types.UUID `json:"id" yaml:"id"`

					// Kind Optional property which defines paths which should be matched with 'self'. Here 'kind' is valid Component 'kind' belonging to the above specifed model. eg: If model is Kubernetes, valid 'kind' are 'Pod', 'Secret'. If the value for all paths of 'self' & 'kind' along with the value of all paths inside 'to.match.self' & 'to.match.kind are equal then the component with 'kind' act as an binded component. eg: ClusterRole, ClusterRoleBinding and ServiceAccount. If the paths for ClusterRole & ClusterRoleBinding and ServiceAccount & ClusterRoleBinding are equal then ClusterRoleBinding acts as an binding. Make sure the 'kind' value in 'from' and 'to' should be equal.
					Kind *[]string `json:"kind,omitempty"`

					// Self Defines paths which should be matched with 'kind'.
					Self *[]string `json:"self,omitempty"`
				} `json:"match,omitempty"`

				// Model Model of the implicated component. Learn more at https://docs.meshery.io/concepts/models
				Model *ModelDefinition `json:"model,omitempty"`
				Patch *struct {
					// MutatedRef JSONPath (https://en.wikipedia.org/wiki/JSONPath) to property to be patched.
					MutatedRef    *string                                                   `json:"mutatedRef" yaml:"mutatedRef"`
					PatchStrategy *RelationshipDefinitionSelectorsAllowToPatchPatchStrategy `json:"patchStrategy" yaml:"patchStrategy"`
				} `json:"patch,omitempty"`
			} `json:"to"`
		} `json:"allow"`

		// Deny Optional selectors used to define relationships which should not be created / is restricted.
		Deny *struct {
			From []struct {
				// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
				Id    *openapi_types.UUID `json:"id" yaml:"id"`
				Kind  *string             `json:"kind" yaml:"kind"`
				Match *struct {
					// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
					Id *openapi_types.UUID `json:"id" yaml:"id"`

					// Kind Optional property which defines paths which should be matched with 'self'. Here 'kind' is valid Component 'kind' belonging to the above specifed model. eg: If model is Kubernetes, valid 'kind' are 'Pod', 'Secret'. If the value for all paths of 'self' & 'kind' along with the value of all paths inside 'to.match.self' & 'to.match.kind are equal then the component with 'kind' act as an binded component. eg: ClusterRole, ClusterRoleBinding and ServiceAccount. If the paths for ClusterRole & ClusterRoleBinding and ServiceAccount & ClusterRoleBinding are equal then ClusterRoleBinding acts as an binding. Make sure the 'kind' value in 'from' and 'to' should be equal.
					Kind *[]string `json:"kind,omitempty"`

					// Self Defines paths which should be matched with the 'kind' property.
					Self *[]string `json:"self,omitempty"`
				} `json:"match,omitempty"`

				// Model Name of the model implicated by this selector. Learn more at https://docs.meshery.io/concepts/models
				Model *ModelDefinition `json:"model,omitempty"`
				Patch *struct {
					// MutatorRef JSON ref to value from where patch should be applied.
					MutatorRef    *[][]string                                                `json:"mutatorRef,omitempty"`
					PatchStrategy *RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy `json:"patchStrategy" yaml:"patchStrategy"`
				} `json:"patch,omitempty"`
			} `json:"from"`
			To []struct {
				// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
				Id    *openapi_types.UUID `json:"id" yaml:"id"`
				Kind  *string             `json:"kind" yaml:"kind"`
				Match *struct {
					// Id A Universally Unique Identifier used to uniquely identify entites in Meshery. The UUID core defintion is used across different schemas.
					Id *openapi_types.UUID `json:"id" yaml:"id"`

					// Kind Optional property which defines paths which should be matched with 'self'. Here 'kind' is valid Component 'kind' belonging to the above specifed model. eg: If model is Kubernetes, valid 'kind' are 'Pod', 'Secret'. If the value for all paths of 'self' & 'kind' along with the value of all paths inside 'to.match.self' & 'to.match.kind are equal then the component with 'kind' act as an binded component. eg: ClusterRole, ClusterRoleBinding and ServiceAccount. If the paths for ClusterRole & ClusterRoleBinding and ServiceAccount & ClusterRoleBinding are equal then ClusterRoleBinding acts as an binding. Make sure the 'kind' value in 'from' and 'to' should be equal.
					Kind *[]string `json:"kind,omitempty"`

					// Self Defines paths which should be matched with 'kind'.
					Self *[]string `json:"self,omitempty"`
				} `json:"match,omitempty"`

				// Model Model of the implicated component. Learn more at https://docs.meshery.io/concepts/models
				Model *ModelDefinition `json:"model,omitempty"`
				Patch *struct {
					// MutatedRef JSONPath (https://en.wikipedia.org/wiki/JSONPath) to property to be patched.
					MutatedRef    *string                                                  `json:"mutatedRef" yaml:"mutatedRef"`
					PatchStrategy *RelationshipDefinitionSelectorsDenyToPatchPatchStrategy `json:"patchStrategy" yaml:"patchStrategy"`
				} `json:"patch,omitempty"`
			} `json:"to"`
		} `json:"deny,omitempty"`
	} `json:"selectors,omitempty"`

	// SubType Most granular unit of relationship classification. The combination of Kind, Type and SubType together uniquely identify a Relationship.
	SubType string `json:"subType" yaml:"subType"`

	// Type Classification of relationships. Used to group relationships similar in nature.
	Type string `json:"type" yaml:"type"`

	// Version Specifies the version of the relationship definition.
	Version string `json:"version" yaml:"version"`
}

// RelationshipDefinitionKind Kind of the Relationship. Learn more about relationships - https://docs.meshery.io/concepts/logical/relationships.
type RelationshipDefinitionKind string

// RelationshipDefinition_Model_Metadata Metadata containing additional information associated with the model.
type RelationshipDefinition_Model_Metadata struct {
	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor *string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite             *string                `json:"svgWhite" yaml:"svgWhite"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RelationshipDefinitionModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipDefinitionModelStatus string

// RelationshipDefinitionSelectorsAllowFromModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipDefinitionSelectorsAllowFromModelStatus string

// RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy defines model for RelationshipDefinition.Selectors.Allow.From.Patch.PatchStrategy.
type RelationshipDefinitionSelectorsAllowFromPatchPatchStrategy string

// RelationshipDefinitionSelectorsAllowToModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipDefinitionSelectorsAllowToModelStatus string

// RelationshipDefinitionSelectorsAllowToPatchPatchStrategy defines model for RelationshipDefinition.Selectors.Allow.To.Patch.PatchStrategy.
type RelationshipDefinitionSelectorsAllowToPatchPatchStrategy string

// RelationshipDefinitionSelectorsDenyFromModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipDefinitionSelectorsDenyFromModelStatus string

// RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy defines model for RelationshipDefinition.Selectors.Deny.From.Patch.PatchStrategy.
type RelationshipDefinitionSelectorsDenyFromPatchPatchStrategy string

// RelationshipDefinitionSelectorsDenyToModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipDefinitionSelectorsDenyToModelStatus string

// RelationshipDefinitionSelectorsDenyToPatchPatchStrategy defines model for RelationshipDefinition.Selectors.Deny.To.Patch.PatchStrategy.
type RelationshipDefinitionSelectorsDenyToPatchPatchStrategy string

// Getter for additional properties for RelationshipDefinition_Model_Metadata. Returns the specified
// element and whether it was found
func (a RelationshipDefinition_Model_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RelationshipDefinition_Model_Metadata
func (a *RelationshipDefinition_Model_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RelationshipDefinition_Model_Metadata to handle AdditionalProperties
func (a *RelationshipDefinition_Model_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RelationshipDefinition_Model_Metadata to handle AdditionalProperties
func (a RelationshipDefinition_Model_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SvgColor != nil {
		object["svgColor"], err = json.Marshal(a.SvgColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
		}
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.SvgWhite != nil {
		object["svgWhite"], err = json.Marshal(a.SvgWhite)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
