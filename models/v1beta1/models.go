// Package patterns provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package patterns

import (
	"encoding/json"
	"fmt"

	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ComponentsFormat.
const (
	CUE  ComponentsFormat = "CUE"
	JSON ComponentsFormat = "JSON"
)

// Defines values for ComponentsMetadataShape.
const (
	Barrel               ComponentsMetadataShape = "barrel"
	BottomRoundRectangle ComponentsMetadataShape = "bottom-round-rectangle"
	ConcaveHexagon       ComponentsMetadataShape = "concave-hexagon"
	CutRectangle         ComponentsMetadataShape = "cut-rectangle"
	Diamond              ComponentsMetadataShape = "diamond"
	Ellipse              ComponentsMetadataShape = "ellipse"
	Heptagon             ComponentsMetadataShape = "heptagon"
	Hexagon              ComponentsMetadataShape = "hexagon"
	Octagon              ComponentsMetadataShape = "octagon"
	Pentagon             ComponentsMetadataShape = "pentagon"
	Rectangle            ComponentsMetadataShape = "rectangle"
	Rhomboid             ComponentsMetadataShape = "rhomboid"
	RoundDiamond         ComponentsMetadataShape = "round-diamond"
	RoundHeptagon        ComponentsMetadataShape = "round-heptagon"
	RoundHexagon         ComponentsMetadataShape = "round-hexagon"
	RoundOctagon         ComponentsMetadataShape = "round-octagon"
	RoundPentagon        ComponentsMetadataShape = "round-pentagon"
	RoundRectangle       ComponentsMetadataShape = "round-rectangle"
	RoundTag             ComponentsMetadataShape = "round-tag"
	RoundTriangle        ComponentsMetadataShape = "round-triangle"
	Star                 ComponentsMetadataShape = "star"
	Tag                  ComponentsMetadataShape = "tag"
	Triangle             ComponentsMetadataShape = "triangle"
	Vee                  ComponentsMetadataShape = "vee"
)

// Defines values for ComponentsModelStatus.
const (
	ComponentsModelStatusDuplicate ComponentsModelStatus = "duplicate"
	ComponentsModelStatusEnabled   ComponentsModelStatus = "enabled"
	ComponentsModelStatusIgnored   ComponentsModelStatus = "ignored"
)

// Defines values for ModelsStatus.
const (
	ModelsStatusDuplicate ModelsStatus = "duplicate"
	ModelsStatusEnabled   ModelsStatus = "enabled"
	ModelsStatusIgnored   ModelsStatus = "ignored"
)

// Defines values for RelationshipsKind.
const (
	Edge         RelationshipsKind = "edge"
	Hierarchical RelationshipsKind = "hierarchical"
	Sibling      RelationshipsKind = "sibling"
)

// Defines values for RelationshipsModelStatus.
const (
	RelationshipsModelStatusDuplicate RelationshipsModelStatus = "duplicate"
	RelationshipsModelStatusEnabled   RelationshipsModelStatus = "enabled"
	RelationshipsModelStatusIgnored   RelationshipsModelStatus = "ignored"
)

// Defines values for RelationshipsSelectorsAllowFromModelStatus.
const (
	RelationshipsSelectorsAllowFromModelStatusDuplicate RelationshipsSelectorsAllowFromModelStatus = "duplicate"
	RelationshipsSelectorsAllowFromModelStatusEnabled   RelationshipsSelectorsAllowFromModelStatus = "enabled"
	RelationshipsSelectorsAllowFromModelStatusIgnored   RelationshipsSelectorsAllowFromModelStatus = "ignored"
)

// Defines values for RelationshipsSelectorsAllowFromPatchPatchStrategy.
const (
	RelationshipsSelectorsAllowFromPatchPatchStrategyReplace RelationshipsSelectorsAllowFromPatchPatchStrategy = "replace"
)

// Defines values for RelationshipsSelectorsAllowToModelStatus.
const (
	RelationshipsSelectorsAllowToModelStatusDuplicate RelationshipsSelectorsAllowToModelStatus = "duplicate"
	RelationshipsSelectorsAllowToModelStatusEnabled   RelationshipsSelectorsAllowToModelStatus = "enabled"
	RelationshipsSelectorsAllowToModelStatusIgnored   RelationshipsSelectorsAllowToModelStatus = "ignored"
)

// Defines values for RelationshipsSelectorsAllowToPatchPatchStrategy.
const (
	RelationshipsSelectorsAllowToPatchPatchStrategyReplace RelationshipsSelectorsAllowToPatchPatchStrategy = "replace"
)

// Defines values for RelationshipsSelectorsDenyFromModelStatus.
const (
	RelationshipsSelectorsDenyFromModelStatusDuplicate RelationshipsSelectorsDenyFromModelStatus = "duplicate"
	RelationshipsSelectorsDenyFromModelStatusEnabled   RelationshipsSelectorsDenyFromModelStatus = "enabled"
	RelationshipsSelectorsDenyFromModelStatusIgnored   RelationshipsSelectorsDenyFromModelStatus = "ignored"
)

// Defines values for RelationshipsSelectorsDenyFromPatchPatchStrategy.
const (
	RelationshipsSelectorsDenyFromPatchPatchStrategyReplace RelationshipsSelectorsDenyFromPatchPatchStrategy = "replace"
)

// Defines values for RelationshipsSelectorsDenyToModelStatus.
const (
	Duplicate RelationshipsSelectorsDenyToModelStatus = "duplicate"
	Enabled   RelationshipsSelectorsDenyToModelStatus = "enabled"
	Ignored   RelationshipsSelectorsDenyToModelStatus = "ignored"
)

// Defines values for RelationshipsSelectorsDenyToPatchPatchStrategy.
const (
	RelationshipsSelectorsDenyToPatchPatchStrategyReplace RelationshipsSelectorsDenyToPatchPatchStrategy = "replace"
)

// Components Components are reusable building blocks for depicting capabilities defined within models. Learn more at https://docs.meshery.io/concepts/components
type Components struct {
	// Component Component and it's properties.
	Component struct {
		// Kind The unique identifier (name) assigned by the registrant to this component. Example: A Kubernetes Pod is of kind 'Pod'.
		Kind string `json:"kind" yaml:"kind"`

		// Schema JSON schema of the object as defined by the registrant.
		Schema string `json:"schema" yaml:"schema"`

		// Version Version of the component produced by the registrant. Example: APIVersion of a Kubernetes Pod.
		Version string `json:"version" yaml:"version"`
	} `json:"component"`
	Configuration *map[string]string `json:"configuration" yaml:"configuration"`

	// Description A written representation of the purpose and characteristics of the component.
	Description *string `json:"description" yaml:"description"`

	// DisplayName Name of the component in human-readible format.
	DisplayName *string `json:"displayName" yaml:"displayName"`

	// Format Format specifies the format used in the `component.schema` field. JSON is the default.
	Format *ComponentsFormat   `json:"format" yaml:"format"`
	Id     *openapi_types.UUID `json:"id" yaml:"id"`

	// Metadata Metadata contains additional information associated with the component.
	Metadata *Components_Metadata `json:"metadata,omitempty"`

	// Model Reference to the specific registered model to which the component belongs and from which model version, category, and other properties may be referenced. Learn more at https://docs.meshery.io/concepts/models
	Model struct {
		// Category Category of the model.
		Category string `json:"category" yaml:"category"`

		// Description Description of the model.
		Description *string `json:"description" yaml:"description"`

		// DisplayName Human-readable name for the model.
		DisplayName *string `json:"displayName" yaml:"displayName"`

		// Metadata Metadata containing additional information associated with the model.
		Metadata *Components_Model_Metadata `json:"metadata,omitempty"`

		// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31)
		Model *struct {
			// Version Version of the model as defined by the registrant.
			Version string `json:"version" yaml:"version"`
		} `json:"model,omitempty"`

		// Name The unique name for the model within the scope of a registrant.
		Name       string                 `json:"name" yaml:"name"`
		Registrant map[string]interface{} `json:"registrant" yaml:"registrant"`

		// SchemaVersion Specifies the version of the schema used for the definition.
		SchemaVersion *string `json:"schemaVersion" yaml:"schemaVersion"`

		// Status Status of model, including:
		// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
		// - maintenance: model is unavailable for a period of time.
		// - enabled: model is available for use for all users of this Meshery Server.
		// - ignored: model is unavailable for use for all users of this Meshery Server.
		Status *ComponentsModelStatus `json:"status" yaml:"status"`

		// SubCategory Sub-category of the model.
		SubCategory *string `json:"subCategory" yaml:"subCategory"`

		// Version Version of the model definition.
		Version string `json:"version" yaml:"version"`
	} `json:"model"`

	// SchemaVersion Specifies the version of the schema to which the component definition conforms.
	SchemaVersion string `json:"schemaVersion" yaml:"schemaVersion"`

	// Version Version of the component definition.
	Version string `json:"version" yaml:"version"`
}

// ComponentsFormat Format specifies the format used in the `component.schema` field. JSON is the default.
type ComponentsFormat string

// ComponentsMetadataShape Shape of the component used for UI representation.
type ComponentsMetadataShape string

// Components_Metadata Metadata contains additional information associated with the component.
type Components_Metadata struct {
	// Capabilities Meshery manages components in accordance with their specific capabilities. This field explicitly identifies those capabilities largely by what actions a given component supports; e.g. metric-scrape, sub-interface, and so on. This field is extensible. ComponentDefinitions may define a broad array of capabilities, which are in-turn dynamically interpretted by Meshery for full lifecycle management.
	Capabilities *map[string]interface{} `json:"capabilities" yaml:"capabilities"`

	// Genealogy Genealogy represents the various representational states of the component.
	Genealogy *string `json:"genealogy" yaml:"genealogy"`

	// IsAnnotation Identifies whether the component is semantically meaningful or not; identifies whether the component should be treated as deployable entity or is for purposes of logical representation.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color of the component used for UI representation.
	PrimaryColor string `json:"primaryColor" yaml:"primaryColor"`

	// Published 'published' controls whether the component should be registered in Meshery Registry. When the same 'published' property in Models, is set to 'false', the Model property takes precedence with all Entities in the Model not being registered.
	Published *bool `json:"published" yaml:"published"`

	// SecondaryColor Secondary color of the component used for UI representation.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// Shape Shape of the component used for UI representation.
	Shape ComponentsMetadataShape `json:"shape" yaml:"shape"`

	// SvgColor Colored SVG of the component used for UI representation on light background.
	SvgColor string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete Complete SVG of the component used for UI representation, often inclusive of background.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// SvgWhite White SVG of the component used for UI representation on dark background.
	SvgWhite             string                 `json:"svgWhite" yaml:"svgWhite"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Components_Model_Metadata Metadata containing additional information associated with the model.
type Components_Model_Metadata struct {
	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor *string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite             *string                `json:"svgWhite" yaml:"svgWhite"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ComponentsModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type ComponentsModelStatus string

// Models Meshery Models serve as a portable unit of packaging to define managed entities, their relationships, and capabilities.
type Models struct {
	// Category Category of the model.
	Category string `json:"category" yaml:"category"`

	// Description Description of the model.
	Description *string `json:"description" yaml:"description"`

	// DisplayName Human-readable name for the model.
	DisplayName *string `json:"displayName" yaml:"displayName"`

	// Metadata Metadata containing additional information associated with the model.
	Metadata *Models_Metadata `json:"metadata,omitempty"`

	// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31)
	Model *struct {
		// Version Version of the model as defined by the registrant.
		Version string `json:"version" yaml:"version"`
	} `json:"model,omitempty"`

	// Name The unique name for the model within the scope of a registrant.
	Name       string                 `json:"name" yaml:"name"`
	Registrant map[string]interface{} `json:"registrant" yaml:"registrant"`

	// SchemaVersion Specifies the version of the schema used for the definition.
	SchemaVersion *string `json:"schemaVersion" yaml:"schemaVersion"`

	// Status Status of model, including:
	// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
	// - maintenance: model is unavailable for a period of time.
	// - enabled: model is available for use for all users of this Meshery Server.
	// - ignored: model is unavailable for use for all users of this Meshery Server.
	Status *ModelsStatus `json:"status" yaml:"status"`

	// SubCategory Sub-category of the model.
	SubCategory *string `json:"subCategory" yaml:"subCategory"`

	// Version Version of the model definition.
	Version string `json:"version" yaml:"version"`
}

// Models_Metadata Metadata containing additional information associated with the model.
type Models_Metadata struct {
	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor *string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite             *string                `json:"svgWhite" yaml:"svgWhite"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ModelsStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type ModelsStatus string

// Relationships Relationships define the nature of interaction between interconnected components in Meshery. The combination of relationship properties kind, type, and subtype characterize various genealogical relations among and between components. Relationships have selectors, selector sets, metadata, and optional parameters. Learn more at https://docs.meshery.io/concepts/logical/relationships.
type Relationships struct {
	// EvaluationQuery Determines the policy rule to be used for the evaluation of the relationship.
	EvaluationQuery string `json:"evaluationQuery" yaml:"evaluationQuery"`

	// Kind Kind of the Relationship.
	Kind RelationshipsKind `json:"kind" yaml:"kind"`

	// Metadata Metadata contains additional information associated with the Relationship.
	Metadata *struct {
		// Description Description of the Relationship.
		Description *string `json:"description" yaml:"description"`
	} `json:"metadata,omitempty"`

	// Model Model of the Relationship.
	Model struct {
		// Category Category of the model.
		Category string `json:"category" yaml:"category"`

		// Description Description of the model.
		Description *string `json:"description" yaml:"description"`

		// DisplayName Human-readable name for the model.
		DisplayName *string `json:"displayName" yaml:"displayName"`

		// Metadata Metadata containing additional information associated with the model.
		Metadata *Relationships_Model_Metadata `json:"metadata,omitempty"`

		// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31)
		Model *struct {
			// Version Version of the model as defined by the registrant.
			Version string `json:"version" yaml:"version"`
		} `json:"model,omitempty"`

		// Name The unique name for the model within the scope of a registrant.
		Name       string                 `json:"name" yaml:"name"`
		Registrant map[string]interface{} `json:"registrant" yaml:"registrant"`

		// SchemaVersion Specifies the version of the schema used for the definition.
		SchemaVersion *string `json:"schemaVersion" yaml:"schemaVersion"`

		// Status Status of model, including:
		// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
		// - maintenance: model is unavailable for a period of time.
		// - enabled: model is available for use for all users of this Meshery Server.
		// - ignored: model is unavailable for use for all users of this Meshery Server.
		Status *RelationshipsModelStatus `json:"status" yaml:"status"`

		// SubCategory Sub-category of the model.
		SubCategory *string `json:"subCategory" yaml:"subCategory"`

		// Version Version of the model definition.
		Version string `json:"version" yaml:"version"`
	} `json:"model"`

	// SchemaVersion Specifies the version of the schema used for the definition.
	SchemaVersion string `json:"schemaVersion" yaml:"schemaVersion"`

	// Selectors Selectors are organized as an array, with each item containing a distinct set of selectors that share a common functionality. This structure allows for flexibility in defining relationships, even when different components are involved.
	Selectors *[]struct {
		// Allow Selectors used to define relationships which are allowed.
		Allow *struct {
			From []struct {
				Kind  *string `json:"kind" yaml:"kind"`
				Match *struct {
					// Kind Optional property which defines paths which should be matched with 'self'. Here 'kind' is valid Component 'kind' belonging to the above specifed model. eg: If model is Kubernetes, valid 'kind' are 'Pod', 'Secret'. If the value for all paths of 'self' & 'kind' along with the value of all paths inside 'to.match.self' & 'to.match.kind are equal then the component with 'kind' act as an binded component. eg: ClusterRole, ClusterRoleBinding and ServiceAccount. If the paths for ClusterRole & ClusterRoleBinding and ServiceAccount & ClusterRoleBinding are equal then ClusterRoleBinding acts as an binding. Make sure the 'kind' value in 'from' and 'to' should be equal.
					Kind *[]string `json:"kind,omitempty"`

					// Self Defines paths which should be matched with 'kind'.
					Self *[]string `json:"self,omitempty"`
				} `json:"match,omitempty"`

				// Model Model of the component. Learn more at https://docs.meshery.io/concepts/models
				Model *struct {
					// Category Category of the model.
					Category string `json:"category" yaml:"category"`

					// Description Description of the model.
					Description *string `json:"description" yaml:"description"`

					// DisplayName Human-readable name for the model.
					DisplayName *string `json:"displayName" yaml:"displayName"`

					// Metadata Metadata containing additional information associated with the model.
					Metadata *Relationships_Selectors_Allow_From_Model_Metadata `json:"metadata,omitempty"`

					// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31)
					Model *struct {
						// Version Version of the model as defined by the registrant.
						Version string `json:"version" yaml:"version"`
					} `json:"model,omitempty"`

					// Name The unique name for the model within the scope of a registrant.
					Name       string                 `json:"name" yaml:"name"`
					Registrant map[string]interface{} `json:"registrant" yaml:"registrant"`

					// SchemaVersion Specifies the version of the schema used for the definition.
					SchemaVersion *string `json:"schemaVersion" yaml:"schemaVersion"`

					// Status Status of model, including:
					// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
					// - maintenance: model is unavailable for a period of time.
					// - enabled: model is available for use for all users of this Meshery Server.
					// - ignored: model is unavailable for use for all users of this Meshery Server.
					Status *RelationshipsSelectorsAllowFromModelStatus `json:"status" yaml:"status"`

					// SubCategory Sub-category of the model.
					SubCategory *string `json:"subCategory" yaml:"subCategory"`

					// Version Version of the model definition.
					Version string `json:"version" yaml:"version"`
				} `json:"model,omitempty"`
				Patch *struct {
					// MutatorRef JSON ref to value from where patch should be applied.
					MutatorRef    *[][]string                                        `json:"mutatorRef,omitempty"`
					PatchStrategy *RelationshipsSelectorsAllowFromPatchPatchStrategy `json:"patchStrategy" yaml:"patchStrategy"`
				} `json:"patch,omitempty"`

				// Version A valid semantic version string between 5 and 256 characters. The pattern allows for a major.minor.patch version followed by an optional pre-release tag like '-alpha' or '-beta.2' and an optional build metadata tag like '+build.1.
				Version *string `json:"version" yaml:"version"`
			} `json:"from"`
			To []struct {
				Kind  *string `json:"kind" yaml:"kind"`
				Match *struct {
					// Kind Optional property which defines paths which should be matched with 'self'. Here 'kind' is valid Component 'kind' belonging to the above specifed model. eg: If model is Kubernetes, valid 'kind' are 'Pod', 'Secret'. If the value for all paths of 'self' & 'kind' along with the value of all paths inside 'to.match.self' & 'to.match.kind are equal then the component with 'kind' act as an binded component. eg: ClusterRole, ClusterRoleBinding and ServiceAccount. If the paths for ClusterRole & ClusterRoleBinding and ServiceAccount & ClusterRoleBinding are equal then ClusterRoleBinding acts as an binding. Make sure the 'kind' value in 'from' and 'to' should be equal.
					Kind *[]string `json:"kind,omitempty"`

					// Self Defines paths which should be matched with 'kind'.
					Self *[]string `json:"self,omitempty"`
				} `json:"match,omitempty"`

				// Model Model of the component. Learn more at https://docs.meshery.io/concepts/models
				Model *struct {
					// Category Category of the model.
					Category string `json:"category" yaml:"category"`

					// Description Description of the model.
					Description *string `json:"description" yaml:"description"`

					// DisplayName Human-readable name for the model.
					DisplayName *string `json:"displayName" yaml:"displayName"`

					// Metadata Metadata containing additional information associated with the model.
					Metadata *Relationships_Selectors_Allow_To_Model_Metadata `json:"metadata,omitempty"`

					// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31)
					Model *struct {
						// Version Version of the model as defined by the registrant.
						Version string `json:"version" yaml:"version"`
					} `json:"model,omitempty"`

					// Name The unique name for the model within the scope of a registrant.
					Name       string                 `json:"name" yaml:"name"`
					Registrant map[string]interface{} `json:"registrant" yaml:"registrant"`

					// SchemaVersion Specifies the version of the schema used for the definition.
					SchemaVersion *string `json:"schemaVersion" yaml:"schemaVersion"`

					// Status Status of model, including:
					// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
					// - maintenance: model is unavailable for a period of time.
					// - enabled: model is available for use for all users of this Meshery Server.
					// - ignored: model is unavailable for use for all users of this Meshery Server.
					Status *RelationshipsSelectorsAllowToModelStatus `json:"status" yaml:"status"`

					// SubCategory Sub-category of the model.
					SubCategory *string `json:"subCategory" yaml:"subCategory"`

					// Version Version of the model definition.
					Version string `json:"version" yaml:"version"`
				} `json:"model,omitempty"`
				Patch *struct {
					// MutatedRef JSON ref to value that should be patched.
					MutatedRef    *string                                          `json:"mutatedRef" yaml:"mutatedRef"`
					PatchStrategy *RelationshipsSelectorsAllowToPatchPatchStrategy `json:"patchStrategy" yaml:"patchStrategy"`
				} `json:"patch,omitempty"`

				// Version A valid semantic version string between 5 and 256 characters. The pattern allows for a major.minor.patch version followed by an optional pre-release tag like '-alpha' or '-beta.2' and an optional build metadata tag like '+build.1.
				Version *string `json:"version" yaml:"version"`
			} `json:"to"`
		} `json:"allow,omitempty"`

		// Deny Optional selectors used to define relationships which should not be created / is restricted.
		Deny *struct {
			From []struct {
				Kind  *string `json:"kind" yaml:"kind"`
				Match *struct {
					// Kind Optional property which defines paths which should be matched with 'self'. Here 'kind' is valid Component 'kind' belonging to the above specifed model. eg: If model is Kubernetes, valid 'kind' are 'Pod', 'Secret'. If the value for all paths of 'self' & 'kind' along with the value of all paths inside 'to.match.self' & 'to.match.kind are equal then the component with 'kind' act as an binded component. eg: ClusterRole, ClusterRoleBinding and ServiceAccount. If the paths for ClusterRole & ClusterRoleBinding and ServiceAccount & ClusterRoleBinding are equal then ClusterRoleBinding acts as an binding. Make sure the 'kind' value in 'from' and 'to' should be equal.
					Kind *[]string `json:"kind,omitempty"`

					// Self Defines paths which should be matched with 'kind'.
					Self *[]string `json:"self,omitempty"`
				} `json:"match,omitempty"`

				// Model Model of the component. Learn more at https://docs.meshery.io/concepts/models
				Model *struct {
					// Category Category of the model.
					Category string `json:"category" yaml:"category"`

					// Description Description of the model.
					Description *string `json:"description" yaml:"description"`

					// DisplayName Human-readable name for the model.
					DisplayName *string `json:"displayName" yaml:"displayName"`

					// Metadata Metadata containing additional information associated with the model.
					Metadata *Relationships_Selectors_Deny_From_Model_Metadata `json:"metadata,omitempty"`

					// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31)
					Model *struct {
						// Version Version of the model as defined by the registrant.
						Version string `json:"version" yaml:"version"`
					} `json:"model,omitempty"`

					// Name The unique name for the model within the scope of a registrant.
					Name       string                 `json:"name" yaml:"name"`
					Registrant map[string]interface{} `json:"registrant" yaml:"registrant"`

					// SchemaVersion Specifies the version of the schema used for the definition.
					SchemaVersion *string `json:"schemaVersion" yaml:"schemaVersion"`

					// Status Status of model, including:
					// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
					// - maintenance: model is unavailable for a period of time.
					// - enabled: model is available for use for all users of this Meshery Server.
					// - ignored: model is unavailable for use for all users of this Meshery Server.
					Status *RelationshipsSelectorsDenyFromModelStatus `json:"status" yaml:"status"`

					// SubCategory Sub-category of the model.
					SubCategory *string `json:"subCategory" yaml:"subCategory"`

					// Version Version of the model definition.
					Version string `json:"version" yaml:"version"`
				} `json:"model,omitempty"`
				Patch *struct {
					// MutatorRef JSON ref to value from where patch should be applied.
					MutatorRef    *[][]string                                       `json:"mutatorRef,omitempty"`
					PatchStrategy *RelationshipsSelectorsDenyFromPatchPatchStrategy `json:"patchStrategy" yaml:"patchStrategy"`
				} `json:"patch,omitempty"`

				// Version A valid semantic version string between 5 and 256 characters. The pattern allows for a major.minor.patch version followed by an optional pre-release tag like '-alpha' or '-beta.2' and an optional build metadata tag like '+build.1.
				Version *string `json:"version" yaml:"version"`
			} `json:"from"`
			To []struct {
				Kind  *string `json:"kind" yaml:"kind"`
				Match *struct {
					// Kind Optional property which defines paths which should be matched with 'self'. Here 'kind' is valid Component 'kind' belonging to the above specifed model. eg: If model is Kubernetes, valid 'kind' are 'Pod', 'Secret'. If the value for all paths of 'self' & 'kind' along with the value of all paths inside 'to.match.self' & 'to.match.kind are equal then the component with 'kind' act as an binded component. eg: ClusterRole, ClusterRoleBinding and ServiceAccount. If the paths for ClusterRole & ClusterRoleBinding and ServiceAccount & ClusterRoleBinding are equal then ClusterRoleBinding acts as an binding. Make sure the 'kind' value in 'from' and 'to' should be equal.
					Kind *[]string `json:"kind,omitempty"`

					// Self Defines paths which should be matched with 'kind'.
					Self *[]string `json:"self,omitempty"`
				} `json:"match,omitempty"`

				// Model Model of the component. Learn more at https://docs.meshery.io/concepts/models
				Model *struct {
					// Category Category of the model.
					Category string `json:"category" yaml:"category"`

					// Description Description of the model.
					Description *string `json:"description" yaml:"description"`

					// DisplayName Human-readable name for the model.
					DisplayName *string `json:"displayName" yaml:"displayName"`

					// Metadata Metadata containing additional information associated with the model.
					Metadata *Relationships_Selectors_Deny_To_Model_Metadata `json:"metadata,omitempty"`

					// Model Registrant-defined data associated with the model. Properties pertain to the software being managed (e.g. Kubernetes v1.31)
					Model *struct {
						// Version Version of the model as defined by the registrant.
						Version string `json:"version" yaml:"version"`
					} `json:"model,omitempty"`

					// Name The unique name for the model within the scope of a registrant.
					Name       string                 `json:"name" yaml:"name"`
					Registrant map[string]interface{} `json:"registrant" yaml:"registrant"`

					// SchemaVersion Specifies the version of the schema used for the definition.
					SchemaVersion *string `json:"schemaVersion" yaml:"schemaVersion"`

					// Status Status of model, including:
					// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
					// - maintenance: model is unavailable for a period of time.
					// - enabled: model is available for use for all users of this Meshery Server.
					// - ignored: model is unavailable for use for all users of this Meshery Server.
					Status *RelationshipsSelectorsDenyToModelStatus `json:"status" yaml:"status"`

					// SubCategory Sub-category of the model.
					SubCategory *string `json:"subCategory" yaml:"subCategory"`

					// Version Version of the model definition.
					Version string `json:"version" yaml:"version"`
				} `json:"model,omitempty"`
				Patch *struct {
					// MutatedRef JSON ref to value that should be patched.
					MutatedRef    *string                                         `json:"mutatedRef" yaml:"mutatedRef"`
					PatchStrategy *RelationshipsSelectorsDenyToPatchPatchStrategy `json:"patchStrategy" yaml:"patchStrategy"`
				} `json:"patch,omitempty"`

				// Version A valid semantic version string between 5 and 256 characters. The pattern allows for a major.minor.patch version followed by an optional pre-release tag like '-alpha' or '-beta.2' and an optional build metadata tag like '+build.1.
				Version *string `json:"version" yaml:"version"`
			} `json:"to"`
		} `json:"deny,omitempty"`
	} `json:"selectors,omitempty"`

	// SubType Used for further classification of Relationships. Type and SubType together identifies a Relationship.
	SubType string `json:"subType" yaml:"subType"`

	// Type Classification of relationships. Used to group relationships similar in nature.
	Type string `json:"type" yaml:"type"`

	// Version Specifies the version of the definition.
	Version string `json:"version" yaml:"version"`
}

// RelationshipsKind Kind of the Relationship.
type RelationshipsKind string

// Relationships_Model_Metadata Metadata containing additional information associated with the model.
type Relationships_Model_Metadata struct {
	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor *string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite             *string                `json:"svgWhite" yaml:"svgWhite"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RelationshipsModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipsModelStatus string

// Relationships_Selectors_Allow_From_Model_Metadata Metadata containing additional information associated with the model.
type Relationships_Selectors_Allow_From_Model_Metadata struct {
	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor *string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite             *string                `json:"svgWhite" yaml:"svgWhite"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RelationshipsSelectorsAllowFromModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipsSelectorsAllowFromModelStatus string

// RelationshipsSelectorsAllowFromPatchPatchStrategy defines model for Relationships.Selectors.Allow.From.Patch.PatchStrategy.
type RelationshipsSelectorsAllowFromPatchPatchStrategy string

// Relationships_Selectors_Allow_To_Model_Metadata Metadata containing additional information associated with the model.
type Relationships_Selectors_Allow_To_Model_Metadata struct {
	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor *string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite             *string                `json:"svgWhite" yaml:"svgWhite"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RelationshipsSelectorsAllowToModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipsSelectorsAllowToModelStatus string

// RelationshipsSelectorsAllowToPatchPatchStrategy defines model for Relationships.Selectors.Allow.To.Patch.PatchStrategy.
type RelationshipsSelectorsAllowToPatchPatchStrategy string

// Relationships_Selectors_Deny_From_Model_Metadata Metadata containing additional information associated with the model.
type Relationships_Selectors_Deny_From_Model_Metadata struct {
	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor *string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite             *string                `json:"svgWhite" yaml:"svgWhite"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RelationshipsSelectorsDenyFromModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipsSelectorsDenyFromModelStatus string

// RelationshipsSelectorsDenyFromPatchPatchStrategy defines model for Relationships.Selectors.Deny.From.Patch.PatchStrategy.
type RelationshipsSelectorsDenyFromPatchPatchStrategy string

// Relationships_Selectors_Deny_To_Model_Metadata Metadata containing additional information associated with the model.
type Relationships_Selectors_Deny_To_Model_Metadata struct {
	// IsAnnotation Indicates whether the model and its entities should be treated as deployable entities or as logical representations.
	IsAnnotation *bool `json:"isAnnotation" yaml:"isAnnotation"`

	// PrimaryColor Primary color associated with the model.
	PrimaryColor *string `json:"primaryColor" yaml:"primaryColor"`

	// SecondaryColor Secondary color associated with the model.
	SecondaryColor *string `json:"secondaryColor" yaml:"secondaryColor"`

	// SvgColor SVG representation of the model in colored format.
	SvgColor *string `json:"svgColor" yaml:"svgColor"`

	// SvgComplete SVG representation of the complete model.
	SvgComplete *string `json:"svgComplete" yaml:"svgComplete"`

	// SvgWhite SVG representation of the model in white color.
	SvgWhite             *string                `json:"svgWhite" yaml:"svgWhite"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RelationshipsSelectorsDenyToModelStatus Status of model, including:
// - duplicate: this component is a duplicate of another. The component that is to be the canonical reference and that is duplicated by other components should not be assigned the 'duplicate' status.
// - maintenance: model is unavailable for a period of time.
// - enabled: model is available for use for all users of this Meshery Server.
// - ignored: model is unavailable for use for all users of this Meshery Server.
type RelationshipsSelectorsDenyToModelStatus string

// RelationshipsSelectorsDenyToPatchPatchStrategy defines model for Relationships.Selectors.Deny.To.Patch.PatchStrategy.
type RelationshipsSelectorsDenyToPatchPatchStrategy string

// Getter for additional properties for Components_Metadata. Returns the specified
// element and whether it was found
func (a Components_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Components_Metadata
func (a *Components_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Components_Metadata to handle AdditionalProperties
func (a *Components_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["capabilities"]; found {
		err = json.Unmarshal(raw, &a.Capabilities)
		if err != nil {
			return fmt.Errorf("error reading 'capabilities': %w", err)
		}
		delete(object, "capabilities")
	}

	if raw, found := object["genealogy"]; found {
		err = json.Unmarshal(raw, &a.Genealogy)
		if err != nil {
			return fmt.Errorf("error reading 'genealogy': %w", err)
		}
		delete(object, "genealogy")
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["published"]; found {
		err = json.Unmarshal(raw, &a.Published)
		if err != nil {
			return fmt.Errorf("error reading 'published': %w", err)
		}
		delete(object, "published")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["shape"]; found {
		err = json.Unmarshal(raw, &a.Shape)
		if err != nil {
			return fmt.Errorf("error reading 'shape': %w", err)
		}
		delete(object, "shape")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Components_Metadata to handle AdditionalProperties
func (a Components_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Capabilities != nil {
		object["capabilities"], err = json.Marshal(a.Capabilities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capabilities': %w", err)
		}
	}

	if a.Genealogy != nil {
		object["genealogy"], err = json.Marshal(a.Genealogy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'genealogy': %w", err)
		}
	}

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	object["primaryColor"], err = json.Marshal(a.PrimaryColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
	}

	if a.Published != nil {
		object["published"], err = json.Marshal(a.Published)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'published': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	object["shape"], err = json.Marshal(a.Shape)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'shape': %w", err)
	}

	object["svgColor"], err = json.Marshal(a.SvgColor)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	object["svgWhite"], err = json.Marshal(a.SvgWhite)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Components_Model_Metadata. Returns the specified
// element and whether it was found
func (a Components_Model_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Components_Model_Metadata
func (a *Components_Model_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Components_Model_Metadata to handle AdditionalProperties
func (a *Components_Model_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Components_Model_Metadata to handle AdditionalProperties
func (a Components_Model_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SvgColor != nil {
		object["svgColor"], err = json.Marshal(a.SvgColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
		}
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.SvgWhite != nil {
		object["svgWhite"], err = json.Marshal(a.SvgWhite)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Models_Metadata. Returns the specified
// element and whether it was found
func (a Models_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Models_Metadata
func (a *Models_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Models_Metadata to handle AdditionalProperties
func (a *Models_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Models_Metadata to handle AdditionalProperties
func (a Models_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SvgColor != nil {
		object["svgColor"], err = json.Marshal(a.SvgColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
		}
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.SvgWhite != nil {
		object["svgWhite"], err = json.Marshal(a.SvgWhite)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Relationships_Model_Metadata. Returns the specified
// element and whether it was found
func (a Relationships_Model_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Relationships_Model_Metadata
func (a *Relationships_Model_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Relationships_Model_Metadata to handle AdditionalProperties
func (a *Relationships_Model_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Relationships_Model_Metadata to handle AdditionalProperties
func (a Relationships_Model_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SvgColor != nil {
		object["svgColor"], err = json.Marshal(a.SvgColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
		}
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.SvgWhite != nil {
		object["svgWhite"], err = json.Marshal(a.SvgWhite)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Relationships_Selectors_Allow_From_Model_Metadata. Returns the specified
// element and whether it was found
func (a Relationships_Selectors_Allow_From_Model_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Relationships_Selectors_Allow_From_Model_Metadata
func (a *Relationships_Selectors_Allow_From_Model_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Relationships_Selectors_Allow_From_Model_Metadata to handle AdditionalProperties
func (a *Relationships_Selectors_Allow_From_Model_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Relationships_Selectors_Allow_From_Model_Metadata to handle AdditionalProperties
func (a Relationships_Selectors_Allow_From_Model_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SvgColor != nil {
		object["svgColor"], err = json.Marshal(a.SvgColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
		}
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.SvgWhite != nil {
		object["svgWhite"], err = json.Marshal(a.SvgWhite)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Relationships_Selectors_Allow_To_Model_Metadata. Returns the specified
// element and whether it was found
func (a Relationships_Selectors_Allow_To_Model_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Relationships_Selectors_Allow_To_Model_Metadata
func (a *Relationships_Selectors_Allow_To_Model_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Relationships_Selectors_Allow_To_Model_Metadata to handle AdditionalProperties
func (a *Relationships_Selectors_Allow_To_Model_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Relationships_Selectors_Allow_To_Model_Metadata to handle AdditionalProperties
func (a Relationships_Selectors_Allow_To_Model_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SvgColor != nil {
		object["svgColor"], err = json.Marshal(a.SvgColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
		}
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.SvgWhite != nil {
		object["svgWhite"], err = json.Marshal(a.SvgWhite)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Relationships_Selectors_Deny_From_Model_Metadata. Returns the specified
// element and whether it was found
func (a Relationships_Selectors_Deny_From_Model_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Relationships_Selectors_Deny_From_Model_Metadata
func (a *Relationships_Selectors_Deny_From_Model_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Relationships_Selectors_Deny_From_Model_Metadata to handle AdditionalProperties
func (a *Relationships_Selectors_Deny_From_Model_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Relationships_Selectors_Deny_From_Model_Metadata to handle AdditionalProperties
func (a Relationships_Selectors_Deny_From_Model_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SvgColor != nil {
		object["svgColor"], err = json.Marshal(a.SvgColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
		}
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.SvgWhite != nil {
		object["svgWhite"], err = json.Marshal(a.SvgWhite)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Relationships_Selectors_Deny_To_Model_Metadata. Returns the specified
// element and whether it was found
func (a Relationships_Selectors_Deny_To_Model_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Relationships_Selectors_Deny_To_Model_Metadata
func (a *Relationships_Selectors_Deny_To_Model_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Relationships_Selectors_Deny_To_Model_Metadata to handle AdditionalProperties
func (a *Relationships_Selectors_Deny_To_Model_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["isAnnotation"]; found {
		err = json.Unmarshal(raw, &a.IsAnnotation)
		if err != nil {
			return fmt.Errorf("error reading 'isAnnotation': %w", err)
		}
		delete(object, "isAnnotation")
	}

	if raw, found := object["primaryColor"]; found {
		err = json.Unmarshal(raw, &a.PrimaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'primaryColor': %w", err)
		}
		delete(object, "primaryColor")
	}

	if raw, found := object["secondaryColor"]; found {
		err = json.Unmarshal(raw, &a.SecondaryColor)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryColor': %w", err)
		}
		delete(object, "secondaryColor")
	}

	if raw, found := object["svgColor"]; found {
		err = json.Unmarshal(raw, &a.SvgColor)
		if err != nil {
			return fmt.Errorf("error reading 'svgColor': %w", err)
		}
		delete(object, "svgColor")
	}

	if raw, found := object["svgComplete"]; found {
		err = json.Unmarshal(raw, &a.SvgComplete)
		if err != nil {
			return fmt.Errorf("error reading 'svgComplete': %w", err)
		}
		delete(object, "svgComplete")
	}

	if raw, found := object["svgWhite"]; found {
		err = json.Unmarshal(raw, &a.SvgWhite)
		if err != nil {
			return fmt.Errorf("error reading 'svgWhite': %w", err)
		}
		delete(object, "svgWhite")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Relationships_Selectors_Deny_To_Model_Metadata to handle AdditionalProperties
func (a Relationships_Selectors_Deny_To_Model_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.IsAnnotation != nil {
		object["isAnnotation"], err = json.Marshal(a.IsAnnotation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isAnnotation': %w", err)
		}
	}

	if a.PrimaryColor != nil {
		object["primaryColor"], err = json.Marshal(a.PrimaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryColor': %w", err)
		}
	}

	if a.SecondaryColor != nil {
		object["secondaryColor"], err = json.Marshal(a.SecondaryColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryColor': %w", err)
		}
	}

	if a.SvgColor != nil {
		object["svgColor"], err = json.Marshal(a.SvgColor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgColor': %w", err)
		}
	}

	if a.SvgComplete != nil {
		object["svgComplete"], err = json.Marshal(a.SvgComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgComplete': %w", err)
		}
	}

	if a.SvgWhite != nil {
		object["svgWhite"], err = json.Marshal(a.SvgWhite)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'svgWhite': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
